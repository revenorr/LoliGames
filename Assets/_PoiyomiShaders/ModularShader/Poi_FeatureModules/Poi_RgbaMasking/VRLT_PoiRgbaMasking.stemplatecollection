#T#PoiRGBAMaskingProperties
// RGBA Masking
[HideInInspector] m_start_RGBMask ("RGBA Color Masking--{reference_property:_RGBMaskEnabled}", Float) = 0
[HideInInspector][ThryToggle(VIGNETTE)]_RGBMaskEnabled ("RGB Mask Enabled", Float) = 0
[ToggleUI]_RGBUseVertexColors ("Use Vertex Colors", Float) = 0
[ToggleUI]_RGBBlendMultiplicative ("Multiplicative?", Float) = 0
_RGBMask ("Mask--{reference_properties:[_RGBMaskPan, _RGBMaskUV]}", 2D) = "white" { }
[HideInInspector][Vector2]_RGBMaskPan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RGBMaskUV ("UV", int) = 0
_RedColor ("R Color", Color) = (1, 1, 1, 1)
_RedTexure ("R Texture--{reference_properties:[_RedTexurePan, _RedTexureUV]}", 2D) = "white" { }
[HideInInspector][Vector2]_RedTexurePan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RedTexureUV ("UV", int) = 0
_GreenColor ("G Color", Color) = (1, 1, 1, 1)
_GreenTexture ("G Texture--{reference_properties:[_GreenTexturePan, _GreenTextureUV]}", 2D) = "white" { }
[HideInInspector][Vector2]_GreenTexturePan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_GreenTextureUV ("UV", int) = 0
_BlueColor ("B Color", Color) = (1, 1, 1, 1)
_BlueTexture ("B Texture--{reference_properties:[_BlueTexturePan, _BlueTextureUV]}", 2D) = "white" { }
[HideInInspector][Vector2]_BlueTexturePan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_BlueTextureUV ("UV", int) = 0
_AlphaColor ("A Color", Color) = (1, 1, 1, 1)
_AlphaTexture ("A Texture--{reference_properties:[_AlphaTexturePan, _AlphaTextureUV]}", 2D) = "white" { }
[HideInInspector][Vector2]_AlphaTexturePan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_AlphaTextureUV ("UV", int) = 0

// RGB MASKED NORMALS
[ThryToggle(GEOM_TYPE_MESH)]_RgbNormalsEnabled ("Enable Normals", Float) = 0
[ToggleUI]_RGBNormalBlend ("Blend with Base--{condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", Float) = 0
[Normal]_RgbNormalR ("R Normal--{reference_properties:[_RgbNormalRPan, _RgbNormalRUV],condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", 2D) = "bump" { }
[HideInInspector][Vector2]_RgbNormalRPan ("Pan", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RgbNormalRUV ("UV", int) = 0
_RgbNormalRScale ("Intensity--{condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", Range(0, 10)) = 0
[Normal]_RgbNormalG ("G Normal--{reference_properties:[_RgbNormalGPan, _RgbNormalGUV],condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", 2D) = "bump" { }
[HideInInspector][Vector2]_RgbNormalGPan ("Pan", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RgbNormalGUV ("UV", int) = 0
_RgbNormalGScale ("Intensity--{condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", Range(0, 10)) = 0
[Normal]_RgbNormalB ("B Normal--{reference_properties:[_RgbNormalBPan, _RgbNormalBUV],condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", 2D) = "bump" { }
[HideInInspector][Vector2]_RgbNormalBPan ("Pan", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RgbNormalBUV ("UV", int) = 0
_RgbNormalBScale ("Intensity--{condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", Range(0, 10)) = 0
[Normal]_RgbNormalA ("A Normal--{reference_properties:[_RgbNormalAPan, _RgbNormalAUV],condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", 2D) = "bump" { }
[HideInInspector][Vector2]_RgbNormalAPan ("Pan", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)]_RgbNormalAUV ("UV", int) = 0
_RgbNormalAScale ("Intensity--{condition_show:{type:PROPERTY_BOOL,data:_RgbNormalsEnabled==1}}", Range(0, 10)) = 0
[HideInInspector] m_end_RGBMask ("RGB Color Masking", Float) = 0

#T#PoiRGBAMaskingKeywords
#pragma shader_feature VIGNETTE
#pragma shader_feature GEOM_TYPE_MESH

#T#PoiRGBAMaskingVariables
#ifdef VIGNETTE
    #if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
        Texture2D _RGBMask;
    #endif
    float4 _RGBMask_ST;
    float2 _RGBMaskPan;
    float _RGBMaskUV;

    #if defined(PROP_REDTEXURE) || !defined(OPTIMIZER_ENABLED)
        Texture2D _RedTexure;
    #endif
    float4 _RedTexure_ST;
    float2 _RedTexurePan;
    float _RedTexureUV;

    #if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
        Texture2D _GreenTexture;
    #endif
    float4 _GreenTexture_ST;
    float2 _GreenTexturePan;
    float _GreenTextureUV;

    #if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
        Texture2D _BlueTexture;
    #endif
    float4 _BlueTexture_ST;
    float2 _BlueTexturePan;
    float _BlueTextureUV;

    #if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
        Texture2D _AlphaTexture;
    #endif
    float4 _AlphaTexture_ST;
    float2 _AlphaTexturePan;
    float _AlphaTextureUV;

    #ifdef GEOM_TYPE_MESH
        #if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
            Texture2D _RgbNormalR;
        #endif
        float4 _RgbNormalR_ST;
        float2 _RgbNormalRPan;
        float _RgbNormalRUV;
        float _RgbNormalRScale;

        #if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
            Texture2D _RgbNormalG;
        #endif
        float4 _RgbNormalG_ST;
        float2 _RgbNormalGPan;
        float _RgbNormalGUV;
        float _RgbNormalGScale;

        #if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
            Texture2D _RgbNormalB;
        #endif
        float4 _RgbNormalB_ST;
        float2 _RgbNormalBPan;
        float _RgbNormalBUV;
        float _RgbNormalBScale;

        #if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
            Texture2D _RgbNormalA;
        #endif
        float4 _RgbNormalA_ST;
        float2 _RgbNormalAPan;
        float _RgbNormalAUV;
        float _RgbNormalAScale;

        float _RgbNormalsEnabled;
    #endif
    
    float4 _RedColor;
    float4 _GreenColor;
    float4 _BlueColor;
    float4 _AlphaColor;
    
    float _RGBBlendMultiplicative;
    float _RGBUseVertexColors;
    float _RGBNormalBlend;
#endif

/*
Texture2D ;
float4 _ST;
float2 Pan;
float UV;
*/

#T#PoiRGBAMaskingFunctions
#ifdef VIGNETTE
    #if defined(GEOM_TYPE_MESH) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_FORWARDOUTLINE)
        void calculateRGBNormals(inout PoiMesh poiMesh)
        {
            float4 rgbMask;
            //UNITY_BRANCH
            if (_RGBUseVertexColors)
            {
                rgbMask = poiMesh.vertexColor;
            }
            else
            {
                #if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
                    rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
                #else
                    rgbMask = 1;
                #endif
            }
            
            //UNITY_BRANCH
            if (_RgbNormalsEnabled)
            {
                //UNITY_BRANCH
                if (_RGBNormalBlend == 0)
                {
                    //UNITY_BRANCH
                    if (_RgbNormalRScale > 0)
                    {
                        half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan), _RgbNormalRScale);
                        poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, rgbMask.r);
                    }

                    //UNITY_BRANCH
                    if (_RgbNormalGScale > 0)
                    {
                        half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan), _RgbNormalGScale);
                        poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, rgbMask.g);
                    }

                    //UNITY_BRANCH
                    if (_RgbNormalBScale > 0)
                    {
                        half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan), _RgbNormalBScale);
                        poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, rgbMask.b);
                    }

                    //UNITY_BRANCH
                    if (_RgbNormalAScale > 0)
                    {
                        half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan), _RgbNormalAScale);
                        poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, rgbMask.a);
                    }
                }
                else
                {
                    half3 newNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan), _RgbNormalRScale * rgbMask.r);
                    half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan), _RgbNormalGScale * rgbMask.g);
                    newNormal = BlendNormals(newNormal, normalToBlendWith);
                    normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan), _RgbNormalBScale * rgbMask.b);
                    newNormal = BlendNormals(newNormal, normalToBlendWith);
                    normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan), _RgbNormalAScale * rgbMask.a);
                    newNormal = BlendNormals(newNormal, normalToBlendWith);
                    poiMesh.tangentSpaceNormal = BlendNormals(newNormal, poiMesh.tangentSpaceNormal);
                }
            }
        }
    #endif
    void calculateRGBMask(inout PoiFragData poiFragData, in PoiMesh poiMesh)
    {
        //If RGB normals are in use this data will already exist
        float4 rgbMask = float4(1, 1, 1, 1);
        //UNITY_BRANCH
        if (_RGBUseVertexColors)
        {
            rgbMask = poiMesh.vertexColor;
        }
        else
        {
            #if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
                rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
            #else
                rgbMask = 1;
            #endif
        }
        
        #if defined(PROP_REDTEXURE) || !defined(OPTIMIZER_ENABLED)
            float4 red = POI2D_SAMPLER_PAN(_RedTexure, _MainTex, poiUV(poiMesh.uv[_RedTexureUV], _RedTexure_ST), _RedTexurePan);
        #else
            float4 red = 1;
        #endif
        #if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
            float4 green = POI2D_SAMPLER_PAN(_GreenTexture, _MainTex, poiUV(poiMesh.uv[_GreenTextureUV], _GreenTexture_ST), _GreenTexturePan);
        #else
            float4 green = 1;
        #endif
        #if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
            float4 blue = POI2D_SAMPLER_PAN(_BlueTexture, _MainTex, poiUV(poiMesh.uv[_BlueTextureUV], _BlueTexture_ST), _BlueTexturePan);
        #else
            float4 blue = 1;
        #endif
        #if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
            float4 alpha = POI2D_SAMPLER_PAN(_AlphaTexture, _MainTex, poiUV(poiMesh.uv[_AlphaTextureUV], _AlphaTexture_ST), _AlphaTexturePan);
        #else
            float4 alpha = 1;
        #endif
        
        //UNITY_BRANCH
        if (_RGBBlendMultiplicative)
        {
            float3 RGBColor = 1;
            RGBColor = lerp(RGBColor, red.rgb * _RedColor.rgb, rgbMask.r * red.a * _RedColor.a);
            RGBColor = lerp(RGBColor, green.rgb * _GreenColor.rgb, rgbMask.g * green.a * _GreenColor.a);
            RGBColor = lerp(RGBColor, blue.rgb * _BlueColor.rgb, rgbMask.b * blue.a * _BlueColor.a);
            RGBColor = lerp(RGBColor, alpha.rgb * _AlphaColor.rgb, rgbMask.a * alpha.a * _AlphaColor.a);
            
            poiFragData.baseColor *= RGBColor;
        }
        else
        {
            poiFragData.baseColor = lerp(poiFragData.baseColor, red.rgb * _RedColor.rgb, rgbMask.r * red.a * _RedColor.a);
            poiFragData.baseColor = lerp(poiFragData.baseColor, green.rgb * _GreenColor.rgb, rgbMask.g * green.a * _GreenColor.a);
            poiFragData.baseColor = lerp(poiFragData.baseColor, blue.rgb * _BlueColor.rgb, rgbMask.b * blue.a * _BlueColor.a);
            poiFragData.baseColor = lerp(poiFragData.baseColor, alpha.rgb * _AlphaColor.rgb, rgbMask.a * alpha.a * _AlphaColor.a);
        }
    }
#endif

#T#PoiRGBAMaskingColorFunctionCall
#ifdef VIGNETTE
    calculateRGBMask(poiFragData, poiMesh);
#endif

#T#PoiRGBAMaskingNormalFunctionCall
#if defined(GEOM_TYPE_MESH) && defined(VIGNETTE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_FORWARDOUTLINE)
    calculateRGBNormals(poiMesh);
#endif
